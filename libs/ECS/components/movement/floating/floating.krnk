#include <g.krnk>
# ===================================================================
# Library: libs\ECS\bounce\ecsgrav.krnk
# Author: blandrice
#   Description: gravity
# ===================================================================

# num MAXYVEL = 100;

# num action sign(num d){
#     return d >= 0 ? 1 : -1;
# }

num action applysin(obj tobj, str dim, num t)
{
    num offset = (num)tobj.floating.offset;
    if (dim=="x")
    {
        return (num)tobj.floating.ogpos.x + ((num)tobj.floating.amplitude.x* Math.sin((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
    } 
    else if (dim=="y")
    {
        return (num)tobj.floating.ogpos.y + ((num)tobj.floating.amplitude.y* Math.sin((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
    }
    else if (dim=="z")
    {
        return (num)tobj.floating.ogpos.z + ((num)tobj.floating.amplitude.z* Math.sin((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
    }
    return 0;
}

num action applycos(obj tobj, str dim, num t)
{
    num offset = (num)tobj.floating.offset;
    if (dim=="x")
    {
        return (num)tobj.floating.ogpos.x + ((num)tobj.floating.amplitude.x* Math.cos((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
    } 
    else if (dim=="y")
    {
        return (num)tobj.floating.ogpos.y + ((num)tobj.floating.amplitude.y* Math.cos((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
    }
    else if (dim=="z")
    {
        return (num)tobj.floating.ogpos.z + ((num)tobj.floating.amplitude.z* Math.cos((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
    }
    return 0;
}

private action onECSUpdate(num delta, obj tobj, obj[] objlist){
if (notEmpty (obj) tobj.floating) 
    {
        # GAME.log("floating not empty");
        
        # (num)tobj.floating.ogpos.x
        # (num)tobj.floating.ogpos.y
        # (num)tobj.floating.ogpos.z

        # (num)tobj.floating.amplitude.x
        # (num)tobj.floating.amplitude.y
        # (num)tobj.floating.amplitude.z

        # tobj.floating.t_msinterval
        # tobj.floating._tstart

        # (str)tobj.floating.type #sine,linear

        num t = (g_tnow - (num)tobj.floating._tstart);
        if (t > (num)tobj.floating.t_msinterval)
        {
            tobj.floating._tstart = g_tnow;
        }
        
        # else if ((str)tobj.floating.type == "sine")
        # else if (notEmpty (obj)tobj.floating){
        # {
        # GAME.log("floating type is sine");
        # GAME.log(tobj);
        if ((num)tobj.floating.amplitude.x !=0)
        {
            # tobj.position.x = (num)tobj.floating.ogpos.x + ((num)tobj.floating.amplitude.x* Math.sin((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
            if ((str)tobj.floating.type.x=="sine")
            {
                tobj.position.x = applysin(tobj,"x",t);
            } 
            else if ((str)tobj.floating.type.x=="cos")
            {
                tobj.position.x = applycos(tobj,"x",t);
            }
        }
        if ((num)tobj.floating.amplitude.y !=0)
        {
            # tobj.position.y = (num)tobj.floating.ogpos.y + ((num)tobj.floating.amplitude.y* Math.sin((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
            # tobj.position.y = applysin(tobj,"y",t);
            if ((str)tobj.floating.type.y=="sine")
            {
                tobj.position.y = applysin(tobj,"y",t);
            } 
            else if ((str)tobj.floating.type.y=="cos")
            {
                tobj.position.y = applycos(tobj,"y",t);
            }
        }
        if ((num)tobj.floating.amplitude.z !=0)
        {
            # tobj.position.z = (num)tobj.floating.ogpos.z + ((num)tobj.floating.amplitude.z* Math.sin((((Math.PI2)*t) / (num)tobj.floating.t_msinterval)+(Math.PI2*offset)));
            # tobj.position.z = applysin(tobj,"z",t);
            if ((str)tobj.floating.type.z=="sine")
            {
                tobj.position.z = applysin(tobj,"z",t);
            } 
            else if ((str)tobj.floating.type.z=="cos")
            {
                tobj.position.z = applycos(tobj,"z",t);
            }
        }
        # } 
        else # default is no movement
        {

        }
        # # (num) tobj.velocity.y += (num) tobj.gravity.y*(delta/1000);
        # (num) tobj.velocity.y += (num) tobj.gravity.y*(delta/1000);
        # if (Math.abs((num) tobj.velocity.y) > MAXYVEL){
        #     tobj.velocity.y = sign((num) tobj.velocity.y) * MAXYVEL;
        # }

    }
}