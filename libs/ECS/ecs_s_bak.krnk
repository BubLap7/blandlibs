#include <syncobjs_s.krnk>
#include <AABB.krnk>
#include <vec.krnk>

str action closestPlayer(obj position){
    
	obj[] plrs = GAME.PLAYERS.list();
    num mindist = 0;
	str plrid = "";
    for (num i = 0; i < lengthOf plrs; i++) {
		
            obj plr = plrs[i];
            num dist = UTILS.getDist3D(
                (num)plr.position.x,
                (num)plr.position.y,
                (num)plr.position.z,
                (num)position.x,
                (num)position.y,
                (num)position.z
            );
            if (i == 0 || dist < mindist ) {
				mindist = dist;
				plrid = (str) plr.id;
			}
        }
	return plrid;
}

num action sign(num d){
    return d >= 0 ? 1 : -1;
}

num action minlist(num[] list){
    if (lengthOf list > 2){
        num min = list[0];
        for (num i = 1; i < lengthOf list; i++){
            min = (list[i] < min) ? list[i] : min;
        }
		return min;
    } else if (lengthOf list == 1){
        return list[0];
    }
    else if (lengthOf list == 2) {
        return Math.min(list[0],list[1]);
    }
    return 0;
}
# ===================================================================
# Library: \libs\ECS\ecs_s.krnk
# Author: blandrice
#   Description: Entity! Component!! System!!!
# ===================================================================

#############################################
# Entities: obj list
#############################################
# syncobjs_s_objlist

#############################################
# Components: 
#############################################
# physics/movement
num WORLDFLOOR = -100;
# obj bounce = {x:0,y:0.2,z:0,};
# obj gravity = {x:0,y:-0.01,z:0};
num MAXYVEL = 100;

# health / death
obj health = {health: 100, fullhealth:100};

# collide with player
obj collide = {plr:true,onplrcol:"inflict_5;hurt_50"};
# obj collide = {plr:true,onplrcol:"inflict_5;hurt_50"};



# follow player
obj behavior = {idle:"none",plr:"followplr"};
#walkspeed


# team
obj team = {team:"enemy"};
# obj team = {team:"1"};

#############################################
# Systems: public actions + onNetworkMessage hooks
#############################################
action onPlayerCollision(){
    obj[] plrs = GAME.PLAYERS.list();
    for (num i = 0; i < lengthOf plrs; i++){

    }
}

public action update(num delta){
    obj[] world = GAME.OBJECTS.list();
    for (num i = 0; i < lengthOf syncobjs_s_objlist; i++)
    {
        obj tobj = syncobjs_s_objlist[i];
        
        # physics/movement
        # behavior
        if (notEmpty (obj)tobj.behavior){
            
            # if ((str)tobj.behavior.default == "followplr"){
            #     GAME.log("followplayer behavior found");
            #     GAME.log(tobj);
            #         obj plr = GAME.PLAYERS.findByID(closestPlayer((obj)tobj.position));
                    
            #         obj udir = vec_unitDir((obj)tobj.position,(obj)plr.position);
            #         GAME.log(udir);
            #         tobj.velocity.x = (num)udir.x * (num)tobj.walkspeed.x;
            #         tobj.velocity.z = (num)udir.z * (num)tobj.walkspeed.z;
            #         GAME.log(tobj.velocity.x, tobj.velocity.z);
            # }
            
        }

        # gravity
        if (notEmpty (obj) tobj.gravity && (num) tobj.onground == 0 ) 
        {
            (num) tobj.velocity.y += (num) tobj.gravity.y*(delta/1000);
            if (Math.abs((num) tobj.velocity.y) > MAXYVEL){
                tobj.velocity.y = sign((num) tobj.velocity.y) * MAXYVEL;
            }

        }

        # detect world collision
        bool detectedcollision = false;
        for (num j = 0; j < lengthOf world; j++){
            obj wcube = {
                position:{
                    x:(num)world[j].position.x,
                    y:(num)world[j].position.y - (num)world[j].scale.y,
                    z:(num)world[j].position.z
                },
                scale: {
                    x:(num)world[j].scale.x*2,
                    y:(num)world[j].scale.y*2,
                    z:(num)world[j].scale.z*2
                }
            };
           
            # apply velocity movement + collision resolution
            if (notEmpty (obj) tobj.velocity && notEmpty (obj) tobj.position)
            {
                # predict future position
                obj cubefuture = {
                    position:{
                        x:(num)tobj.position.x + (num)tobj.velocity.x*delta/1000,
                        y:(num)tobj.position.y + (num)tobj.velocity.y*delta/1000,
                        z:(num)tobj.position.z + (num)tobj.velocity.z*delta/1000,
                    },
                    scale: tobj.scale
                };


                # If future collision:
                if (AABB_isCollision(cubefuture,wcube))
                {
                    detectedcollision = true;
                    
                    # distance of object to world cube
                    obj d = AABB_CalculateAabbDistanceTo(tobj,wcube);
                    if ((str)tobj.debug == "1"){
                        GAME.log("hi");
                        GAME.log(tobj.position);
                        GAME.log(wcube.position);
                        GAME.log((num)tobj.position.y + (num)tobj.scale.y/2);
                        GAME.log((num)wcube.position.y + (num)wcube.scale.y/2);
                        GAME.log("tobj posy",(num)tobj.position.y);
                        GAME.log("wcube posy",(num)wcube.position.y);
                        GAME.log("wcube scaley",(num)wcube.scale.y);
                        GAME.log(Math.abs((num)tobj.position.y - ((num)wcube.position.y + (num)wcube.scale.y )));
                        
                    }
                    
                    # .onground property
                    # if (((num)tobj.position.y + (num)tobj.scale.y/2) > ((num)wcube.position.y + (num)wcube.scale.y/2) && (lengthOf times == 0)){}
                    if ( ((num)d.x <= 0 && (num)d.z <=0) && Math.abs((num)tobj.position.y - ((num)wcube.position.y + (num)wcube.scale.y )) < 2){
                        tobj.onground = 1;
                    }

                    # time it takes to hit the cube on that axis
                    num tx = (num)d.x < 0 ? 0 : (((num)tobj.velocity.x == 0) ? 0 : ((num)d.x/Math.abs((num)tobj.velocity.x)));
                    num ty = (num)d.y < 0 ? 0 : (((num)tobj.velocity.y == 0) ? 0 : ((num)d.y/Math.abs((num)tobj.velocity.y)));
                    num tz = (num)d.z < 0 ? 0 : (((num)tobj.velocity.z == 0) ? 0 : ((num)d.z/Math.abs((num)tobj.velocity.z)));
                    num[] times = num[tx,ty,tz];
                    
                    # if time == 0, remove it (not considered for lerping)
                    for (num k = lengthOf times-1; k >=0; k--)
                    {
                        if (times[k] == 0){
                            remove times[k];
                        }
                    }
                    
                    if ((str)tobj.debug == "1"){
                        GAME.log("times:",times);
                    }

                    # lerp based on minimum time to surfaces contact
                    if (lengthOf times > 0){
                        num minT = minlist(times);

                        # if (notEmpty (obj) tobj.behavior){}
                        if ((str) tobj.debug == "1"){
                            GAME.log("T:");
                            GAME.log(tx,ty,tz,",mint:",minT);
                            GAME.log(d);
                            GAME.log((num)d.x/Math.abs((num)tobj.velocity.x),(num)d.y/Math.abs((num)tobj.velocity.y),(num)d.z/Math.abs((num)tobj.velocity.z));
                        }

                        (num)tobj.position.x += (minT * (num)tobj.velocity.x);
                        (num)tobj.position.y += (minT * (num)tobj.velocity.y);
                        (num)tobj.position.z += (minT * (num)tobj.velocity.z);
                        
                        # some rounding otherwise weird clipping happens
                        if (tx == minT)
                        {
                            tobj.position.x = Math.round((num)tobj.position.x);
                        }
                        if (ty == minT) 
                        {
                            tobj.position.y = Math.round((num)tobj.position.y);
                        }
                        if (tz == minT) 
                        {
                            tobj.position.z = Math.round((num)tobj.position.z);
                        }
                    
                        # resolve collision (bounce or bonk)
                        if (notEmpty (obj) tobj.bounce) 
                        {
                            tobj.velocity.x = (-1) * (num)tobj.velocity.x * (num)tobj.bounce.x;
                            tobj.velocity.y = (-1) * (num)tobj.velocity.y * (num)tobj.bounce.y;
                            tobj.velocity.z = (-1) * (num)tobj.velocity.z * (num)tobj.bounce.z;
                        } else {
                            if (tx == minT) {tobj.velocity.x = 0;}
                            if (ty == minT) {tobj.velocity.y = 0;}
                            if (tz == minT) {tobj.velocity.z = 0;}
                            
                        }
                        
                    } 
                    break; #done, collision detected
                } 
            }
        }
        if (!detectedcollision){
            tobj.onground = 0;
        }
        (num) tobj.position.x += (num)tobj.velocity.x * (delta/1000);
        (num) tobj.position.y += (num)tobj.velocity.y * (delta/1000);
        (num) tobj.position.z += (num)tobj.velocity.z * (delta/1000);
        
        if ((str) tobj.debug == "1"){
            GAME.log(tobj);
        }
    } 


}

public action onNetworkMessage(str id, obj data, str playerID) {

}

