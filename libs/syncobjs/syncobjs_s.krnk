#include <dtypes.krnk>
#include <b91.krnk>


# ===================================================================
# Library: \libs\syncobjs\syncobjs_s.krnk
# Author: blandrice
#   Description: not ready!
# ===================================================================

num SYNC_INTERVAL = 50;

# object contents
num[] action objsToByteArray(obj[] objlist) {
	num[] retArray = num[];
	for (num i = 0; i < lengthOf objlist; i++) {
		obj tObj = objlist[i];
		num[] tArray = num[];

		# 1 byte (8bits) object contents
		num contents = 0x00;
		num contentsidx = lengthOf retArray;
		addTo retArray contents;
		if ((num) tObj.hit>0) {contents |=  0x80;}
		
		# 2 bytes objid
		tArray = dtypes_int16toByteArray(dtypes_numToUint16((num)tObj.objid)); addTo retArray tArray[0]; addTo retArray tArray[1];

		# 4 bytes health/fhealth
		if (notEmpty (obj) tObj.health) {
			contents |=  0x40;
			tArray = dtypes_int16toByteArray(dtypes_numToUint16((num)tObj.health.h)); addTo retArray tArray[0]; addTo retArray tArray[1];
			tArray = dtypes_int16toByteArray(dtypes_numToUint16((num)tObj.health.fh)); addTo retArray tArray[0]; addTo retArray tArray[1];
		}
		# 6 bytes position
		if (notEmpty (obj) tObj.position) {
			contents |=  0x20;
			tArray = dtypes_int16toByteArray(dtypes_numToInt16((num)tObj.position.x)); addTo retArray tArray[0]; addTo retArray tArray[1];
			tArray = dtypes_int16toByteArray(dtypes_numToInt16((num)tObj.position.y)); addTo retArray tArray[0]; addTo retArray tArray[1];
			tArray = dtypes_int16toByteArray(dtypes_numToInt16((num)tObj.position.z)); addTo retArray tArray[0]; addTo retArray tArray[1];
		}
		# 6 bytes rotation
		if (notEmpty (obj) tObj.rotation) {
			contents |=  0x10;
			tArray = dtypes_int16toByteArray(dtypes_numToFloat16((num)tObj.rotation.x)); addTo retArray tArray[0]; addTo retArray tArray[1];
            # GAME.log("x: ",dtypes_numToFloat16((num)tObj.rotation.x), printBinary(dtypes_numToFloat16((num)tObj.rotation.x)));
			tArray = dtypes_int16toByteArray(dtypes_numToFloat16((num)tObj.rotation.y)); addTo retArray tArray[0]; addTo retArray tArray[1];
			tArray = dtypes_int16toByteArray(dtypes_numToFloat16((num)tObj.rotation.z)); addTo retArray tArray[0]; addTo retArray tArray[1];
		}
		# 6 bytes scale
		if (notEmpty (obj) tObj.scale) {
			contents |=  0x08;
			tArray = dtypes_int16toByteArray(dtypes_numToInt16((num)tObj.scale.x)); addTo retArray tArray[0]; addTo retArray tArray[1];
			tArray = dtypes_int16toByteArray(dtypes_numToInt16((num)tObj.scale.y)); addTo retArray tArray[0]; addTo retArray tArray[1];
			tArray = dtypes_int16toByteArray(dtypes_numToInt16((num)tObj.scale.z)); addTo retArray tArray[0]; addTo retArray tArray[1];
		}
		# 7 bytes details (2 type, 2 texture, 3 color)
        if (!!tObj.type && (num)tObj.type != (num)tObj.type_old){
            # type (cube, sphere, modelID)
			tObj.type_old = tObj.type;
            tArray = dtypes_int16toByteArray((num)tObj.type); addTo retArray tArray[0]; addTo retArray tArray[1];    
            contents |=  0x04;
        }
        if (!!tObj.aid && (num)tObj.aid != (num)tObj.aid_old){
            # type (cube, sphere, modelID)
            tArray = dtypes_int16toByteArray((num)tObj.aid); addTo retArray tArray[0]; addTo retArray tArray[1];    
			tObj.aid_old = tObj.aid;
            contents |=  0x02;
        }
		if ((str) tObj.color !="undefined" && (str)tObj.color != (str)tObj.color_old){
            # type (cube, sphere, modelID)
			tObj.color_old = tObj.color;
            tArray = dtypes_ColorToByteArray((num)tObj.color); addTo retArray tArray[0]; addTo retArray tArray[1]; addTo retArray tArray[2];
            contents |=  0x01;
        }
		retArray[contentsidx] = contents;
	}
	return retArray;
}

num tlastbroadcast = 0;
obj[] objlist = obj[];
num[] newdellist = num[];
num objid = 0;
num tnow = 0;

# WARNING: pass in a fresh object only - not a reference! otherwise you risk modifying the reference
# for example don't pass in a template object for createObject(templateBall).
action createObject(obj d) {
    
    # object template!
    obj tobj = {
        type: 0, #0 = cube, 1 = sphere, 2 = cylinder, all else = modelID
        aid: 34379,
        scale: {x:20,y:80,z:20}, # models only need x:scale which is all 3 dimensions
        position: {x:1,y:1,z:1},
        velocity: {x:0,y:0,z:0},
        rotation: {x:0,y:0,z:0},
        color: 0x00A8F9
    };
    if ((str) d.type == "undefined") {d.type = tobj.type;}
    if ((str) d.aid == "undefined") {d.aid = tobj.aid;}
    if (!notEmpty (obj) d.scale) {d.scale = tobj.scale;}
    if (!notEmpty (obj) d.position) {d.position = tobj.position;}
    if (!notEmpty (obj) d.velocity) {d.velocity = tobj.velocity;}
    if (!notEmpty (obj) d.rotation) {d.rotation = tobj.rotation;}
    if ((str) d.color == "undefined") {d.color = tobj.color;}

	d.objid = toNum toStr objid;
    objid++;
    addTo objlist d;
}

bool action deleteObject(str id) {
    for (num i = lengthOf objlist - 1; i >= 0; i--) {
        if ((str) objlist[i].objid == id) {
            addTo newdellist toNum objlist[i].objid;
            remove objlist[i];
            return true;
        }
    }
    return false;
}

obj action findObjbyID(str id){
    for (num i = lengthOf objlist - 1; i >= 0; i--) {
        if ((str) objlist[i].objid == id) {
            return objlist[i];
        }
    }
    return {};
}

str[] action listObjIDs(){
    str[] list = str[];
    for (num i = 0; i < lengthOf objlist; i++){
        addTo list (str) objlist[i].objid;
    }
    return list;
}

public action start() {
    objlist = obj[];
    objid=0;
}

public action update(num delta) {
	tnow = GAME.TIME.now();

    # Broadcast Synced Objects data
    if ((tnow - tlastbroadcast) > SYNC_INTERVAL) {
        tlastbroadcast = tnow;
        # str encodedobjdata = objencoding();
        str encodedobjdata = b91_encode(objsToByteArray(objlist));

        # bool success = GAME.NETWORK.broadcast("sync", {data:objdata});
        obj[] plrs = GAME.PLAYERS.list();
        bool success=true;
        for (num i = 0; i < lengthOf plrs; i++) {
            success = GAME.NETWORK.send("sync", {d:encodedobjdata, dellist:newdellist}, (str)plrs[i].id);    
        }
        if (!success) {
            GAME.log("ERROR: sync not sent!!!");
        } else {
            newdellist = num[];
        }
    }
}

# Runs when the round ends
public action onGameEnd() {
    # delete all objects client side
    GAME.NETWORK.broadcast("clear", {});
}