# ================================================================
# File: testmap_client.krnk
# Author: blandrice
# ================================================================



# ================================================================
# File: raybox.krnk
# Author: blandrice
# ================================================================

# ================================================================
# CONSTANT DEFINES 
num raybox_MS_DURATION_UNCROUCH = 166;
num raybox_HEIGHT_STAND = 9.5;
num raybox_HEIGHT_CROUCH = 6.2;

# ================================================================
# FUNCTIONS
# ================================================================
obj action raybox_RotToVecAdjusted
(obj  rot, obj options) {
    num a = 0;
    num b = 0;
    num y = 0;
    if (!!options.toRad) {
        a = Math.toRad((num) rot.x); # x roll
        b = Math.toRad((num) rot.y); # y pitch (krunker is yaw)
        y = Math.toRad((num) rot.z); # z yaw (krunker is pitch)
    }
    else {
        a = (num) rot.x; # x roll
        b = (num) rot.y; # y pitch (krunker is yaw)
        y = (num) rot.z; # z yaw (krunker is pitch)
    }
    
    obj ux = {x: Math.cos(b)*Math.cos(y), y: Math.cos(a)*Math.sin(y)+Math.sin(a)*Math.sin(b)*Math.cos(y), z: Math.sin(a)*Math.sin(y)-Math.cos(a)*Math.sin(b)*Math.cos(y)};
    obj uy = {x: -Math.cos(b)*Math.sin(y), y:Math.cos(a)*Math.cos(y)-Math.sin(a)*Math.sin(b)*Math.sin(y), z:Math.sin(a)*Math.cos(y)+Math.cos(a)*Math.sin(b)*Math.sin(y)};
    obj uz = {x: Math.sin(b), y: -Math.sin(a)*Math.cos(b), z: Math.cos(a)*Math.cos(b)};
    return {ux: ux, uy: uy, uz: uz};
}

obj action raybox_cubeBounds(obj cube){
    num[] minB = num[];
    num[] maxB = num[];
    
    addTo minB (num) cube.position.x - (num) cube.scale.x/2; # x
    addTo minB (num) cube.position.y + 0;                    # y
    addTo minB (num) cube.position.z - (num) cube.scale.z/2; # z
    
    addTo maxB (num) cube.position.x + (num) cube.scale.x/2; # x
    addTo maxB (num) cube.position.y + (num) cube.scale.y;   # y
    addTo maxB (num) cube.position.z + (num) cube.scale.z/2; # z

    return {minB:minB,maxB:maxB};
}

# Fast Ray-Box numersection
# by Andrew Woo
# from "Graphics Gems", Academic Press, 1990
bool raybox_FALSE = false;
bool raybox_TRUE = true;
num raybox_NUMDIM = 3;
num raybox_RIGHT = 0;
num raybox_LEFT = 1;
num raybox_MIDDLE = 2;

# minB[raybox_NUMDIM]  , maxB[raybox_NUMDIM];	/* box
# origin[raybox_NUMDIM], dir[raybox_NUMDIM];	/* raybox_ray
# coord[raybox_NUMDIM] 				/* hit point
bool action raybox_HitBoundingBox(
    num[] minB,num[] maxB,
    num[] origin, num[] dir,
    num[] coord) 
{
	bool inside = true;
	num[] quadrant = num[1,2,3];
	num i = 0;
	num whichPlane = 0;
	num[] maxT = num[0,0,0];
	num[] candidatePlane = num[0,0,0];

	# Find candidate planes; this loop can be avoided if
   	# rays cast all from the eye(assume perpsective view)
	for (i=0; i<raybox_NUMDIM; i++) {
        if(origin[i] < minB[i]) {
			quadrant[i] = raybox_LEFT;
			candidatePlane[i] = minB[i];
			inside = raybox_FALSE;
		}else if (origin[i] > maxB[i]) {
			quadrant[i] = raybox_RIGHT;
			candidatePlane[i] = maxB[i];
			inside = raybox_FALSE;
		}else	{
			quadrant[i] = raybox_MIDDLE;
		}
    }
	# Ray origin inside bounding box 
	if(inside)	{
		coord = origin;
		return (raybox_TRUE);
	}
    # Calculate T distances to candidate planes
	for (i = 0; i < raybox_NUMDIM; i++) {
        if (quadrant[i] != raybox_MIDDLE && dir[i] !=0) {
            maxT[i] = (candidatePlane[i]-origin[i]) / dir[i];
        } else {
            maxT[i] = -1;
        }
    }
	# Get largest of the maxT's for final choice of numersection 
	whichPlane = 0;
	for (i = 1; i < raybox_NUMDIM; i++) {
        if (maxT[whichPlane] < maxT[i]) {
            whichPlane = i;
        }
    }
	# Check final candidate actually inside box 
	if (maxT[whichPlane] < 0) {return (raybox_FALSE);}
	for (i = 0; i < raybox_NUMDIM; i++){
        if (whichPlane != i) {
			coord[i] = origin[i] + maxT[whichPlane] *dir[i];
			if (coord[i] < minB[i] || coord[i] > maxB[i]){
                return (raybox_FALSE);
            }
		} else {
			coord[i] = candidatePlane[i];
		}
    }
		
	return raybox_TRUE; # Ray hits box
}

# ================================================================
# INITIALIZE VARIABLES
# ================================================================
obj raybox_ray = {};
obj raybox_cube_tohit = {};
# obj cube_dir_t_ux = {};
# obj cube_dir_t_uy = {};
# obj cube_dir_t_uz = {};
bool raybox_plrSpawned = false;
num raybox_tnow = 0;
num raybox_tlastStand = 0;
num raybox_tlastCrouch = 0;
num raybox_shootheight = 0;

# ================================================================
# KRUNKSCRIPT GAME ACTIONS
# ================================================================
# Runs when the game starts
action raybox_start() {
    str aid = "34379"; # temp fix for now
    # GAME.SCENE.addCube(aid, "#FF0000", 0,0,0, 10,10,10, {});
    
    raybox_cube_tohit = GAME.SCENE.addCube(aid, "#FF0000", 0,0,0, 3,3,3, {opacity:0.5});
    # cube_dir_t_ux = GAME.SCENE.addCube(aid, "#FF0000", 0,0,0, 3,3,3, {opacity:0.5});
    # cube_dir_t_uy = GAME.SCENE.addCube(aid, "#00FF00", 0,0,0, 3,3,3, {opacity:0.5});
    # cube_dir_t_uz = GAME.SCENE.addCube(aid, "#0000FF", 0,0,0, 3,3,3, {opacity:0.5});
}

# Runs every game tick
action raybox_update(num delta) {
    if (raybox_plrSpawned){
        
        # cube_dir_t_ux.position.x = (num) raybox_ray.origin.x + (num) raybox_ray.dir.ux.x * 5;
        # cube_dir_t_ux.position.y = (num) raybox_ray.origin.y + (num) raybox_ray.dir.ux.y * 5;
        # cube_dir_t_ux.position.z = (num) raybox_ray.origin.z + (num) raybox_ray.dir.ux.z * 5;

        # cube_dir_t_uy.position.x = (num) raybox_ray.origin.x + (num) raybox_ray.dir.uy.x * 5;
        # cube_dir_t_uy.position.y = (num) raybox_ray.origin.y + (num) raybox_ray.dir.uy.y * 5;
        # cube_dir_t_uy.position.z = (num) raybox_ray.origin.z + (num) raybox_ray.dir.uy.z * 5;

        # cube_dir_t_uz.position.x = (num) raybox_ray.origin.x + (num) raybox_ray.dir.uz.x * 5;
        # cube_dir_t_uz.position.y = (num) raybox_ray.origin.y + (num) raybox_ray.dir.uz.y * 5;
        # cube_dir_t_uz.position.z = (num) raybox_ray.origin.z + (num) raybox_ray.dir.uz.z * 5;
    }
    
}

# Add rendering logic in here
action raybox_render(num delta) {

}

# Player spawns in
action raybox_onPlayerSpawn(str id) {
    obj plr = GAME.PLAYERS.getSelf();
    raybox_plrSpawned = true;
    raybox_ray = {origin:{x:plr.position.x,y:plr.position.y,z:plr.position.z},rotation:{x:0,y:0,z:0},dir:{x:0,y:0,z:0}};
}

# Player died
action raybox_onPlayerDeath(str id, str killerID) {

}

# Player update
action raybox_onPlayerUpdate(str id, num delta, obj inputs) {
    obj plr = GAME.PLAYERS.getSelf();
    raybox_tnow = GAME.TIME.now();
    # GAME.log(plr);
    # GAME.log(inputs);

    
    # raybox_shootheight
    if (!!inputs.crouch) {
        raybox_tlastCrouch = raybox_tnow;
        if ((raybox_tnow - raybox_tlastStand) < raybox_MS_DURATION_UNCROUCH) {
            raybox_shootheight = Math.max(Math.lerp(raybox_HEIGHT_STAND,raybox_HEIGHT_CROUCH,(raybox_tnow - raybox_tlastStand)/raybox_MS_DURATION_UNCROUCH),raybox_HEIGHT_CROUCH);
        }
    } else {
        raybox_tlastStand = raybox_tnow;
        raybox_shootheight = Math.min(Math.lerp(raybox_HEIGHT_CROUCH,raybox_HEIGHT_STAND,(raybox_tnow - raybox_tlastCrouch)/raybox_MS_DURATION_UNCROUCH),raybox_HEIGHT_STAND);
    } # raybox_shootheight


    # raybox_ray origin
    raybox_ray.origin.x = (num) plr.position.x;
    raybox_ray.origin.y = (num) plr.position.y + raybox_shootheight;
    raybox_ray.origin.z = (num) plr.position.z;
    # raybox_ray rotation
    raybox_ray.rotation.y = (num) plr.rotation.x + Math.PI/2;
	raybox_ray.rotation.z = plr.rotation.y;
    # raybox_ray direction
    raybox_ray.dir = raybox_RotToVecAdjusted((obj)raybox_ray.rotation, {toRad:false});

    # detect raybox_ray-box AABB hit
    obj bounds = raybox_cubeBounds(raybox_cube_tohit);
    
    num[] origin = num[(num)raybox_ray.origin.x, (num)raybox_ray.origin.y, (num)raybox_ray.origin.z];
    num[] dir = num[(num)raybox_ray.dir.ux.x, (num)raybox_ray.dir.ux.y, (num)raybox_ray.dir.ux.z];
    num[] coord = num[0,0,0];
    bool didHit = raybox_HitBoundingBox((num[])bounds.minB, (num[])bounds.maxB, origin, dir, coord);
    if (didHit){
        raybox_cube_tohit.opacity = 1;
        GAME.log(coord);
    } else {
        raybox_cube_tohit.opacity = 0.5;
    }

    



}

# # User pressed a key
# public action onKeyPress(str key, num code) {

# }

# # User released a key
# public action onKeyUp(str key, num code) {

# }

# # User held a key
# public action onKeyHeld(str key, num code) {

# }

# # User pressed a button on a controller
# public action onControllerPress(str key, num code) {

# }

# # User released a button on a controller
# public action onControllerUp(str key, num code) {

# }

# # User held a button on a controller
# public action onControllerHeld(str key, num code) {

# }

# # User clicked on screen
# public action onMouseClick(num button, num x, num y) {

# }

# # User released clicked on screen
# public action onMouseUp(num button, num x, num y) {

# }

# # User scrolled on screen
# public action onMouseScroll(num dir) {

# }

# # User clicked a DIV (ID)
# public action onDIVClicked(str id) {

# }

# # Client receives network message
# public action onNetworkMessage(str id, obj data) {

# }# ================================================================
# File: float16.krnk
# Author: blandrice
# ================================================================

num action float16_numToUint16(num x){
	return (x & 0xFFFF); # cap 65536 
}

num action float16_findMSBLoc(num v){
	# v better be an integer u dumbo
	num r = 0;
	v = v >> 1;
	while (v > 0) {
		r++;
		v = v >> 1;
	}
	return r;
}
	

num action float16_fmod(num x, num r){
	return x - (r*Math.floor(x / r));	
}

num action float16_constrainRadians(num x){
	x = float16_fmod(x,Math.PI2);
	if (x < 0){
		x += 360;
	}
    return x;
}
str action float16_printBinary(num f){
	str retstr = "";
	for (num i = 32-1; i >= 0; i--) {
		retstr += toStr (f >> i & 0x1);
	}
	return retstr;
}
num action float16_ones(num f){
	num retnum = 0;
	for (num i = 0; i < f; i++){
		retnum = (retnum << 1) | 1;
	}
	return retnum;	
}

num float16_MAX_BITS = 16;
num float16_BITS_EXP = 3;
num float16_BIAS = 2**(float16_BITS_EXP-1)-1;
# num float16_BITS_MANT = 12;
num float16_BITS_MANT = float16_MAX_BITS - 1 - float16_BITS_EXP;
num float16_SIGN_LOC = float16_MAX_BITS-1;
num action float16_radToFloat16(num data) {
	GAME.log("##### NUM --> FLOAT16 #####");
	GAME.log("float16_BIAS: ",float16_BIAS);
	# normalize to [0, 2pi]
# 	data = float16_constrainRadians(data);
	# sign bit
	num signbit = 0;
	if (data < 0) {signbit = 1; data = -data;}
	GAME.log("sign bit: ", signbit);
	# Convert  whole / decimal bits to pure binary
	num whole = Math.floor(data); # # whole number [0,2PI] noninclusive is already between 0 - 8
	num wholebit = whole; 
	num decimal = (data - whole > 0) ? data - whole : 0;
	num decbit = 0x000; 
	GAME.log("whole bit: ",wholebit);
	# convert decimals into binary
	 # 2 ^-7 
	for (num i = 0; i < float16_BITS_MANT; i++){
		GAME.log("current decimal: ",decimal);
		decimal *= 2;
		num tdecbit = (decimal >= 1 ? 1 : 0);
		decbit |=  tdecbit << (float16_BITS_MANT-1-i); # 12 - i 
		if (decimal >= 1) {decimal -=1;}
		GAME.log("decimal bit ", float16_BITS_MANT-1-i , ": ",tdecbit);
	}
	GAME.log("final decimal bits ", float16_printBinary(decbit));
	num purbinary = (wholebit << float16_BITS_MANT) | decbit;
	GAME.log("pure binary: ", float16_printBinary(purbinary));
	# normalize to determine mantissa and unbiased exponent
	num unbiasedexp = float16_findMSBLoc(purbinary) - float16_BITS_MANT;
	num biasedexp = unbiasedexp + float16_BIAS;
	GAME.log("unbiased exp: ", unbiasedexp);
	GAME.log("biased exp: ", biasedexp);
	GAME.log("biased exp bin: ", float16_printBinary(biasedexp));
	
	# num mantissa = purbinary ^ (1 << (float16_findMSBLoc(purbinary))); # remove leading 1 (MSB)
	num mantissa = 0;
	GAME.log("mantissa with remove leading 1: ",float16_printBinary(mantissa));
	# num mantissa = 0;
	if (float16_findMSBLoc(mantissa) > float16_BITS_MANT-1)	{ # truncate to # of bits?
		mantissa = mantissa >> float16_findMSBLoc(mantissa) - (float16_BITS_MANT-1);
		GAME.log("mantissa truncating required: ", float16_printBinary(mantissa));
		# at this point rounding would be done for the last bit but I'm lazy
	} else { # else, right pad with zeros
		mantissa = (mantissa << (float16_BITS_MANT - 1 - float16_findMSBLoc(mantissa)));
		GAME.log("mantissa padding required: ", float16_printBinary(mantissa));
	}

	
	num float16 = (signbit << float16_SIGN_LOC) | (biasedexp << float16_BITS_MANT) | ( mantissa );
	return float16;
}

num action float16_float16ToRad(num f) {
	GAME.log("##### FLOAT16 --> NUM #####");
	GAME.log("binary: ", float16_printBinary(f));
	GAME.log("sign bit: ", float16_printBinary((f >> float16_SIGN_LOC) & 0x1));	
	# Determine sign
	num sign = (((f >> float16_SIGN_LOC) & 0x1) > 0) ? -1 : 1;
	GAME.log("sign bit: ", sign);
	# Determine exponent 2*e 
	num exp = (f >> float16_BITS_MANT) & float16_ones(float16_BITS_EXP); 
	GAME.log("biased exp: ", exp);
	exp -= float16_BIAS;
	GAME.log("unbiased exp: ", exp);
	# Convert mantissa to denary
	num mantissa = f & float16_ones(float16_BITS_MANT);
	GAME.log("mantissa: ", float16_printBinary(mantissa));
	num mantden = 0;
	for (num i = float16_findMSBLoc(mantissa); i >=0 ; i--) {
		num tman = 1/(2**(float16_BITS_MANT-i)) * ((mantissa >> i) & 0x1);
		GAME.log("mantissa ",i,": ",tman);
# 		mantden += 1/(2**(float16_BITS_MANT-i)) * ((mantissa >> i) & 0x1);
		mantden += tman;
		
	}
	mantden += 1; # add 1 back 
	GAME.log("mantissaden: ", mantden);
	num Rad = sign * mantden * (2 ** exp);
	return Rad;
}

# Runs when the game starts
action float16_start() {
# 	num Rad = 0.09375;
# 	num Rad = -123.3;
# 	num Rad = 6.1;
	num Rad = Math.PI;
# 	num Rad = 58.5;
	GAME.log("number: ",Rad);
	num radfloat16 = float16_radToFloat16(Rad);
	num back2rad = float16_float16ToRad(radfloat16);
	GAME.log("number: ",Rad);
	GAME.log("float16: ", float16_printBinary(radfloat16));
	GAME.log("back to number: ", back2rad);
	

}
# ================================================================
# FUNCTIONS
# ================================================================
obj action TESTLIBS(obj  rot, obj options) {
    num a = 0;
    num b = 0;
    num y = 0;
    if (!!options.toRad) {
        a = Math.toRad((num) rot.x); # x roll
        b = Math.toRad((num) rot.y); # y pitch krunker 
    }
    return {};
}

# Runs every game tick
public action update (num delta) {
    raybox_update(delta);

}
public action start () {
    raybox_start();    float16_start();
    # test blandrice here
    num test = 0;
}


# Add rendering logic in here
public action render (num delta) {
    raybox_render(delta);

}
# Player spawns in
public action onPlayerSpawn (str id) {
    raybox_onPlayerSpawn(id);

}

# ================================================================
# auto-detected public actions from libraries
# ================================================================
public action onPlayerDeath (str id, str killerID) {
    raybox_onPlayerDeath(id,  killerID);
}

public action onPlayerUpdate (str id, num delta, obj inputs) {
    raybox_onPlayerUpdate(id,  delta, obj inputs);
}

